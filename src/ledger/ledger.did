type AggregatorId = nat;
type SubaccountId = nat;
type AssetId = nat;

// An asset can be a fungible or non-fungible token.
// Currently only fungible tokens are defined.
// Non-fungible tokens can be introduced later as a variant.
// A fungible token asset is a pair consisting of the token id (AssetId)
// and the quantity (nat).
type Asset = variant {ft: record {
                            id: AssetId;
                            quantity: nat;
                          };};

// A transfer has contributions from multiple parties, each of which is of the following type.
// A contribution is relative to its owner, i.e. the subaccount id inside it is relative to the owner principal.
// The memo is limited to 256 bytes.
// auto_accept = false indicates that the aggregator waits for acceptance of the owner.
// auto_accept = true indicates that the owner is expected to have auto-accept configured in the ledger (if not the transfer will fail).
type Contribution = 
 record {
   inflow: vec record {
                 SubaccountId;
                 Asset;
               };
   outflow: vec record {
                  SubaccountId;
                  Asset;
                };
   memo: opt blob;
   auto_accept: bool;
 };

// A transfer is a map from owner to the owner's contribution.
// A transfer can specify an optional committer. 
// The committer is the only one who can make an update call and receive the success in the response.
// In that way the committer can process the transfer in a continuation and does not need to rely on polling. 
type Transfer = 
 record {
   map: vec record {
              principal;
              Contribution;
            };
   committer: opt principal;
 };

// The globally unique transfer id
type TransferId = 
 record {
   aid: AggregatorId;
   tid: nat;
 };

// The batches send from aggregator to ledger
type Batch = vec Transfer;

// Result types

type SubaccountId_Result = 
 variant {
   ok: SubaccountId;
   err: variant {NoSpace;};
 };
type Principal_Result = 
 variant {
   ok: principal;
   err: variant {NotFound;};
 };
type Nat_Result = 
 variant {
   ok: nat;
   err: variant {NotFound;};
 };
type Asset_Result = 
 variant {
   ok: Asset;
   err: variant {
          NotFound;
          SubaccountNotFound;
        };
 };
type Assets_Result = 
 variant {
   ok: vec Asset;
   err: variant {NotFound;};
 };

service : {
  // updates

  // open n new subaccounts, caller is considered the owner
  // if the owner isn't known then the owner is newly registered
  // result is the id of the first newly created subaccount
  // the remaining ones are consecutively numbered
  openNewAccounts: (nat) -> (SubaccountId_Result);
 
  // process a batch of transfer, caller must be an aggregator
  processBatch: (Batch) -> (vec variant {
                                  err: nat;
                                  transferId: TransferId;
                                });

  // queries

  // return the number of known aggregators
  nAggregators: () -> (nat) query;

  // return the principal of the n-th aggregator
  // NotFound if it does not exist
  aggregatorPrincipal: (AggregatorId) -> (Principal_Result) query;

  // return the number of subaccounts maintained by the caller
  // 0 if caller is registered but has no subaccounts
  // NotFound if caller is not registered 
  nAccounts: () -> (Nat_Result) query;

  // return the list of assets in the n-th subaccount of the caller
  // NotFound if the caller isn't registered
  // SubaccountNotFound if the caller is registered but does not have n accounts
  asset: (SubaccountId) -> (Asset_Result) query;

  // debug interface

  // return all assets from all subaccounts of the given owner
  // returns a list of lists of assets
  // NotFound if the given owner is not registered
  all_assets: (principal) -> (Assets_Result) query;
}
