{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the High Performance Ledger This documentation resides on GitHub Pages . About The goal is to design and demonstrate a ledger on the Internet Computer that can handle 10,000 transactions per second which are submitted individually by different end users via ingress messages. The number of ingress messages that the consensus mechanism of a single subnet can process is only in the order of 1,000 per second and is in fact rate limited by boundary nodes to a lower number (maybe around 400 per second). Therefore, to get to the desired throughput we plan to utilize 25 subnets. The approach we take is based on the assumption that consensus is indeed the bottleneck and that computation and memory are not bottlenecks. Our approach has a single ledger canister which stores all account balances and settles all transactions. Transactions are not submitted to the ledger directly, though. Instead, end users submit their transactions to aggregators of which there are 25, all on different subnets. Aggregators batch up the transactions and forward them in batches to the ledger. The bottleneck is now the block space available for incoming cross-subnet messages on the subnet that hosts the ledger. If the size of a simple transaction is 100 bytes then each aggregator submits 40kB of data per second to the ledger. For all aggregators combined this occupies 1 MB of block space per second. With some compression techniques we expect that the size of a simple transaction can be reduced to be around 20 bytes, which means a block space requirement of only 200 kB per second. We expect the computational resources required to check 10,000 account balances and update 20,000 account balances per second to be within what a single canister can do. We expect the memory resources required to store 100 million account balances to be within what a single canister can do. We do not expect the ledger to be able to store the history of transactions, but this is not an argument against the design of having a single ledger canister. In fact, even distributing the ledger over 25 subnets would not change the fact that storing the entire history of transactions on chain is impossible. At 10,000 tps and 20 bytes per transaction the history grows by >500 GB per month. Therefore we propose to store only recent history in the ledger canister. The entire history has to be archived off chain but can always be authenticated against root hashes that are stored in the ledger. Features The ledger is a multi-token ledger. This means that multiple tokens, differentiated from each other by a token id, can be hosted on the same ledger canister. All transactions need to be explicitly approved by all parties involved, even the receiver. There are no deposits into arbitrary accounts without approval of the receiver. Multiple token flows can happen atomically in a single transaction. More than two parties can be part of a single transaction and all have to approve. Any party can initiate the transaction: the sender, the receiver or even a third-party. The initiator is paying the fee. API Terminology Canister - conceptual computational unit, executes program in the Internet Computer blockchain Read More Principal - an identifier for an entity on the IC such as a user, a canister (dapps/smart contracts), or a subnet. Read More Subaccount - essentially a wallet, owned by one principal and containing one type of tokens. Client principal can have many subaccounts with different and/or the same tokens Candid types of the API See source files ledger.did and aggregator.did .","title":"Home"},{"location":"#welcome-to-the-high-performance-ledger","text":"This documentation resides on GitHub Pages .","title":"Welcome to the High Performance Ledger"},{"location":"#about","text":"The goal is to design and demonstrate a ledger on the Internet Computer that can handle 10,000 transactions per second which are submitted individually by different end users via ingress messages. The number of ingress messages that the consensus mechanism of a single subnet can process is only in the order of 1,000 per second and is in fact rate limited by boundary nodes to a lower number (maybe around 400 per second). Therefore, to get to the desired throughput we plan to utilize 25 subnets. The approach we take is based on the assumption that consensus is indeed the bottleneck and that computation and memory are not bottlenecks. Our approach has a single ledger canister which stores all account balances and settles all transactions. Transactions are not submitted to the ledger directly, though. Instead, end users submit their transactions to aggregators of which there are 25, all on different subnets. Aggregators batch up the transactions and forward them in batches to the ledger. The bottleneck is now the block space available for incoming cross-subnet messages on the subnet that hosts the ledger. If the size of a simple transaction is 100 bytes then each aggregator submits 40kB of data per second to the ledger. For all aggregators combined this occupies 1 MB of block space per second. With some compression techniques we expect that the size of a simple transaction can be reduced to be around 20 bytes, which means a block space requirement of only 200 kB per second. We expect the computational resources required to check 10,000 account balances and update 20,000 account balances per second to be within what a single canister can do. We expect the memory resources required to store 100 million account balances to be within what a single canister can do. We do not expect the ledger to be able to store the history of transactions, but this is not an argument against the design of having a single ledger canister. In fact, even distributing the ledger over 25 subnets would not change the fact that storing the entire history of transactions on chain is impossible. At 10,000 tps and 20 bytes per transaction the history grows by >500 GB per month. Therefore we propose to store only recent history in the ledger canister. The entire history has to be archived off chain but can always be authenticated against root hashes that are stored in the ledger.","title":"About"},{"location":"#features","text":"The ledger is a multi-token ledger. This means that multiple tokens, differentiated from each other by a token id, can be hosted on the same ledger canister. All transactions need to be explicitly approved by all parties involved, even the receiver. There are no deposits into arbitrary accounts without approval of the receiver. Multiple token flows can happen atomically in a single transaction. More than two parties can be part of a single transaction and all have to approve. Any party can initiate the transaction: the sender, the receiver or even a third-party. The initiator is paying the fee.","title":"Features"},{"location":"#api","text":"","title":"API"},{"location":"#terminology","text":"Canister - conceptual computational unit, executes program in the Internet Computer blockchain Read More Principal - an identifier for an entity on the IC such as a user, a canister (dapps/smart contracts), or a subnet. Read More Subaccount - essentially a wallet, owned by one principal and containing one type of tokens. Client principal can have many subaccounts with different and/or the same tokens","title":"Terminology"},{"location":"#candid-types-of-the-api","text":"See source files ledger.did and aggregator.did .","title":"Candid types of the API"},{"location":"archived_README/","text":"Candid types of the API Ledger API Get number of aggregators Get aggregator principal Get number of open subaccounts Open new subaccount Check balance Process Batch Aggregator API Initialize transaction Approve transaction Reject transaction Get transaction status Candid types of the API Id of token, e.g. currency type TokenId = nat; Id of aggregator type AggregatorId = nat; Balances are Nats in the smallest unit of the token. type Balance = nat; Subaccount ids are issued in consecutive order, without gaps, starting with 0. Extending the range of subaccount ids is an infrequent administrative action on the ledger carried out by the owner principal of the subaccounts. type SubaccountId = nat; Id of transaction, issued by aggregator. The first value specifies the aggregator who issued the transaction id. The second value (nat) is a locally unique value chosen by the aggregator. type TransactionId = record { AggregatorId; nat }; type Transaction = vec Part; type Batch = vec Transaction; type Part = record { owner : principal; flows : vec Flow; memo : opt blob }; type Flow = record { token : TokenId; subaccount : nat; amount : int; }; A record of type Part is only valid if in the sequence of flows the subaccount field is strictly increasing. In particular, there can be at most one flow per subaccount. Ledger API Get number of aggregators Endpoint : nAggregators: () -> (nat) query; Authorization : public Description : returns amount of running aggregator canisters Flow : - return aggregators.size() Get aggregator principal Endpoint : aggregatorPrincipal: (AggregatorId) -> (principal) query; Authorization : public Description : returns principal of selected aggregator. Provided nat is an index and has to be in range 0..{nAggregators()-1} Flow : - return aggregators[aggregatorId] Get number of open subaccounts Endpoint : nAccounts: () -> (nat) query; Authorization : account owner Description : returns the number of open subaccounts for the caller Flow : - obtain ownerId : owners.get(msg.caller) . If it's not defined, return error - return balances[ownerId].size() Open new subaccount Endpoint : openNewAccounts: (TokenId, nat) -> (SubaccountId); Authorization : account owner Description : opens N new subaccounts for the caller and token t. It returns the index of the first new subaccount in the newly created range Flow : - obtain ownerId : owners.get(msg.caller) . If it's not defined: - create it: ownerId = owners.size() - put to the map: owners.put(msg.caller, ownerId) - init balances: balances[ownerId] = [] - extract subaccount array var tokenBalances = balances[ownerId] - remember tokenBalances.size() - append N new TokenBalance entries { unit: tokenId, balance: 0} to tokenBalances - return original array size Check balance Endpoint : balance: (SubaccountId) -> (TokenBalance) query; Authorization : account owner Description : returns wallet balance for provided subaccount number Flow : - obtain ownerId : owners.get(msg.caller) . If it's not defined, return error - return balances[ownerId][subaccountId] Process Batch Endpoint : processBatch: (Batch) -> (vec TransactionId, nat); Authorization : cross-canister call from aggregator Description : processes a batch of newly created transactions. Returns statuses and/or error codes Error codes : - (1): account not found - (2): subaccount not found - (3): token unit mismatch - (4): non-sufficient funds - (5): token flows do not add up to zero - (6): flows are not properly sorted Flow : - check msg.caller - should be one of registered aggregators - initialize array result : can contain either transactionId or error code - loop over each transaction in batch : - init cache array of owners transactionOwners = [] for faster access later - init token amount balance map tokenBalanceMap: Map<TokenId, Int> = ... for checking that the flows for each token add up to zero - loop over each part in transaction (pass #1: validation): - obtain ownerId : owners.get(part.owner) . If it's not defined, put error code 1 to result and continue outer loop. Else push ownerId to transactionOwners cache array - set last_subaccount to -1 - loop over each flow in part - assert that the flow.subaccount > last_subaccount . If not set an error code 6 and continue outer loop. - set last_subaccount to flow.subaccount - get appropriate balance: var tokenBalance = balances[ownerId][flow.subaccount] . If not found, put error code 2 to result and continue outer loop - assert tokenBalance.unit == flow.token else put error code 3 to result and continue outer loop - if tokenBalance.balance + flow.amount < 0 , put error code 4 to result and continue outer loop - add flow.amount to tokenBalanceMap.get(flow.token) , if map does not have this token, add it: tokenBalanceMap.put(flow.token, flow.amount) - loop over tokenBalanceMap - if any element != 0, put error code 5 to result and continue outer loop - loop over each part in transaction , use i as index (pass #2: applying): - loop over each flow in part - modify balance: balances[transactionOwners[i]][flow.subaccount].balance += flow.amount - return result Aggregator API Initialize transaction Endpoint : submit: (Transaction) -> (variant { Ok: TransactionId ; Err }); Authorization : account owner Description : initializes transaction: saves it to memory and waits when some principal call approve or reject on it Flow : - construct TransactionId : { selfAggregatorIndex, transactionsCounter++ } - construct TransactionInfo record: { transaction, submiter: msg.caller, status : { #pending [] } } - put transaction info to pending pendingTransactions.put(transactionId[1], transactionInfo) - return transactionId Approve transaction Endpoint : approve: (TransactionId) -> (variant { Ok; Err }); Authorization : account owner Description : approves transaction by its id Flow : - assert transactionId[0] == selfAggregatorIndex , else throw error - extract transaction info var transactionInfo = pendingTransactions.get(transactionId[1]) - return error if either: - transaction not found - already queued transactionInfo.status.approved != null - rejected transactionInfo.status.rejected == true - put true to transactionInfo.status.pending - if approveance is enough to proceed: - put to batch queue approvedTransaction.enqueue(transactionId[1]) - set approvedTransactions.head_number() to transactionInfo.status.approved Reject transaction Endpoint : reject: (TransactionId) -> (variant { Ok; Err }); Authorization : account owner Description : rejects transaction by its id Flow : - assert transactionId[0] == selfAggregatorIndex , else throw error - extract transaction info var transactionInfo = pendingTransactions.get(transactionId[1]) - if transaction not found or already queued transactionInfo.status.approved != null , return error - put true to transactionInfo.status.rejected Get transaction status Endpoint : transactionDetails: (TransactionId) -> (variant { Ok: TransactionInfo; Err }) query; Authorization : public Description : get status of transaction or error code Flow : - return pendingTransactions.get(transactionId[1])","title":"Archived"},{"location":"archived_README/#candid-types-of-the-api","text":"Id of token, e.g. currency type TokenId = nat; Id of aggregator type AggregatorId = nat; Balances are Nats in the smallest unit of the token. type Balance = nat; Subaccount ids are issued in consecutive order, without gaps, starting with 0. Extending the range of subaccount ids is an infrequent administrative action on the ledger carried out by the owner principal of the subaccounts. type SubaccountId = nat; Id of transaction, issued by aggregator. The first value specifies the aggregator who issued the transaction id. The second value (nat) is a locally unique value chosen by the aggregator. type TransactionId = record { AggregatorId; nat }; type Transaction = vec Part; type Batch = vec Transaction; type Part = record { owner : principal; flows : vec Flow; memo : opt blob }; type Flow = record { token : TokenId; subaccount : nat; amount : int; }; A record of type Part is only valid if in the sequence of flows the subaccount field is strictly increasing. In particular, there can be at most one flow per subaccount.","title":"Candid types of the API"},{"location":"archived_README/#ledger-api","text":"","title":"Ledger API"},{"location":"archived_README/#get-number-of-aggregators","text":"Endpoint : nAggregators: () -> (nat) query; Authorization : public Description : returns amount of running aggregator canisters Flow : - return aggregators.size()","title":"Get number of aggregators"},{"location":"archived_README/#get-aggregator-principal","text":"Endpoint : aggregatorPrincipal: (AggregatorId) -> (principal) query; Authorization : public Description : returns principal of selected aggregator. Provided nat is an index and has to be in range 0..{nAggregators()-1} Flow : - return aggregators[aggregatorId]","title":"Get aggregator principal"},{"location":"archived_README/#get-number-of-open-subaccounts","text":"Endpoint : nAccounts: () -> (nat) query; Authorization : account owner Description : returns the number of open subaccounts for the caller Flow : - obtain ownerId : owners.get(msg.caller) . If it's not defined, return error - return balances[ownerId].size()","title":"Get number of open subaccounts"},{"location":"archived_README/#open-new-subaccount","text":"Endpoint : openNewAccounts: (TokenId, nat) -> (SubaccountId); Authorization : account owner Description : opens N new subaccounts for the caller and token t. It returns the index of the first new subaccount in the newly created range Flow : - obtain ownerId : owners.get(msg.caller) . If it's not defined: - create it: ownerId = owners.size() - put to the map: owners.put(msg.caller, ownerId) - init balances: balances[ownerId] = [] - extract subaccount array var tokenBalances = balances[ownerId] - remember tokenBalances.size() - append N new TokenBalance entries { unit: tokenId, balance: 0} to tokenBalances - return original array size","title":"Open new subaccount"},{"location":"archived_README/#check-balance","text":"Endpoint : balance: (SubaccountId) -> (TokenBalance) query; Authorization : account owner Description : returns wallet balance for provided subaccount number Flow : - obtain ownerId : owners.get(msg.caller) . If it's not defined, return error - return balances[ownerId][subaccountId]","title":"Check balance"},{"location":"archived_README/#process-batch","text":"Endpoint : processBatch: (Batch) -> (vec TransactionId, nat); Authorization : cross-canister call from aggregator Description : processes a batch of newly created transactions. Returns statuses and/or error codes Error codes : - (1): account not found - (2): subaccount not found - (3): token unit mismatch - (4): non-sufficient funds - (5): token flows do not add up to zero - (6): flows are not properly sorted Flow : - check msg.caller - should be one of registered aggregators - initialize array result : can contain either transactionId or error code - loop over each transaction in batch : - init cache array of owners transactionOwners = [] for faster access later - init token amount balance map tokenBalanceMap: Map<TokenId, Int> = ... for checking that the flows for each token add up to zero - loop over each part in transaction (pass #1: validation): - obtain ownerId : owners.get(part.owner) . If it's not defined, put error code 1 to result and continue outer loop. Else push ownerId to transactionOwners cache array - set last_subaccount to -1 - loop over each flow in part - assert that the flow.subaccount > last_subaccount . If not set an error code 6 and continue outer loop. - set last_subaccount to flow.subaccount - get appropriate balance: var tokenBalance = balances[ownerId][flow.subaccount] . If not found, put error code 2 to result and continue outer loop - assert tokenBalance.unit == flow.token else put error code 3 to result and continue outer loop - if tokenBalance.balance + flow.amount < 0 , put error code 4 to result and continue outer loop - add flow.amount to tokenBalanceMap.get(flow.token) , if map does not have this token, add it: tokenBalanceMap.put(flow.token, flow.amount) - loop over tokenBalanceMap - if any element != 0, put error code 5 to result and continue outer loop - loop over each part in transaction , use i as index (pass #2: applying): - loop over each flow in part - modify balance: balances[transactionOwners[i]][flow.subaccount].balance += flow.amount - return result","title":"Process Batch"},{"location":"archived_README/#aggregator-api","text":"","title":"Aggregator API"},{"location":"archived_README/#initialize-transaction","text":"Endpoint : submit: (Transaction) -> (variant { Ok: TransactionId ; Err }); Authorization : account owner Description : initializes transaction: saves it to memory and waits when some principal call approve or reject on it Flow : - construct TransactionId : { selfAggregatorIndex, transactionsCounter++ } - construct TransactionInfo record: { transaction, submiter: msg.caller, status : { #pending [] } } - put transaction info to pending pendingTransactions.put(transactionId[1], transactionInfo) - return transactionId","title":"Initialize transaction"},{"location":"archived_README/#approve-transaction","text":"Endpoint : approve: (TransactionId) -> (variant { Ok; Err }); Authorization : account owner Description : approves transaction by its id Flow : - assert transactionId[0] == selfAggregatorIndex , else throw error - extract transaction info var transactionInfo = pendingTransactions.get(transactionId[1]) - return error if either: - transaction not found - already queued transactionInfo.status.approved != null - rejected transactionInfo.status.rejected == true - put true to transactionInfo.status.pending - if approveance is enough to proceed: - put to batch queue approvedTransaction.enqueue(transactionId[1]) - set approvedTransactions.head_number() to transactionInfo.status.approved","title":"Approve transaction"},{"location":"archived_README/#reject-transaction","text":"Endpoint : reject: (TransactionId) -> (variant { Ok; Err }); Authorization : account owner Description : rejects transaction by its id Flow : - assert transactionId[0] == selfAggregatorIndex , else throw error - extract transaction info var transactionInfo = pendingTransactions.get(transactionId[1]) - if transaction not found or already queued transactionInfo.status.approved != null , return error - put true to transactionInfo.status.rejected","title":"Reject transaction"},{"location":"archived_README/#get-transaction-status","text":"Endpoint : transactionDetails: (TransactionId) -> (variant { Ok: TransactionInfo; Err }) query; Authorization : public Description : get status of transaction or error code Flow : - return pendingTransactions.get(transactionId[1])","title":"Get transaction status"}]}