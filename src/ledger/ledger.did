type AggregatorId = nat;
type SubaccountId = nat;
type AssetId = nat;

// An asset can be a fungible or non-fungible token.
// Currently only fungible tokens are defined.
// Non-fungible tokens can be introduced later as a variant.
// A fungible token asset is a pair consisting of the token id (AssetId)
// and a quantity (nat).
type Asset = variant {ft: record {
                            AssetId;
                            nat;
                          };};

// A transaction has contributions from multiple parties, each of which is of the following type.
// A contribution is relative to its owner, i.e. the subaccount id inside it is relative to the owner principal.
// The memo is limited to 256 bytes.
// auto_approve = false indicates that the aggregator waits for approveance of the owner.
// auto_approve = true indicates that the owner is expected to have auto-approve configured in the ledger (if not the transaction will fail).
type Contribution = 
 record {
   owner : principal;
   inflow: vec record {
                 SubaccountId;
                 Asset;
               };
   outflow: vec record {
                  SubaccountId;
                  Asset;
                };
   memo: opt blob;
   auto_approve: bool;
 };

// A transaction is a map from owner to the owner's contribution.
// A transaction can specify an optional committer. 
// The committer is the only one who can make an update call and receive the success in the response.
// In that way the committer can process the transaction in a continuation and does not need to rely on polling. 
type Tx = 
 record {
   map: vec Contribution;
   committer: opt principal;
 };

// The globally unique transaction id
type GlobalId = record { AggregatorId; nat };

// The batches sent from aggregator to ledger
type Batch = vec Tx;

// Result types

type SubaccountId_Result = 
 variant {
   ok: SubaccountId;
   err: variant {NoSpace;};
 };
type Principal_Result = 
 variant {
   ok: principal;
   err: variant {NotFound;};
 };
type Nat_Result = 
 variant {
   ok: nat;
   err: variant {NotFound;};
 };
type Asset_Result = 
 variant {
   ok: Asset;
   err: variant {
          NotFound;
          SubaccountNotFound;
        };
 };
type Assets_Result = 
 variant {
   ok: vec Asset;
   err: variant {NotFound;};
 };

service : (vec principal) -> {
  // updates

  /* 
  open n new subaccounts for owner = caller
  set the new subaccounts to auto_approve if the second argument (bool) is true
  if the owner isn't known then the owner is newly registered
  return value is the id of the first newly created subaccount
  the remaining ones are consecutively numbered
  */
  openNewAccounts: (nat, bool) -> (SubaccountId_Result);
 
  // process a batch of transaction, caller must be an aggregator
  processBatch: (Batch) -> ();

  // queries

  // return the number of known aggregators
  nAggregators: () -> (nat) query;

  // return the principal of the n-th aggregator
  // NotFound if it does not exist
  aggregatorPrincipal: (AggregatorId) -> (Principal_Result) query;

  // return the number of subaccounts maintained by the caller
  // 0 if caller is registered but has no subaccounts
  // NotFound if caller is not registered 
  nAccounts: () -> (Nat_Result) query;

  // return the asset in the n-th subaccount of the caller
  // NotFound if the caller isn't registered
  // SubaccountNotFound if the caller is registered but does not have n accounts
  asset: (SubaccountId) -> (Asset_Result) query;

  // debug interface

  // return all assets (i.e. all subaccounts) of the given owner
  // NotFound if the given owner is not registered
  all_assets: (principal) -> (Assets_Result) query;
}
